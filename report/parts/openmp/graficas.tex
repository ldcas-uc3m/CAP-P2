\subsection{Métricas}
En esta sección, se incluyen las métricas obtenidas durante la ejecución del programa con paralelismo \textbf{OpenMP}. Quedan recogidas cuatro representaciones gráficas, agrupados dos a dos (HSL y YUV para color y grises), un tipo de representación expone una comparativa con la ejecución secuencial en términos de tiempo y otra, en términos de aceleración. Se dispone de un análisis posterior de las mismas, con el objetivo de definir conclusiones que demuestren qué tan buen rendimiento puede llegar a obtener OpenMP con la optimización implementada.
\rasterfigure[0.9]{hslopenmp1}{Comparativa de tiempos de ejecución HSL.}
\rasterfigure[0.9]{hslopenmp2}{Aceleración del programa OpenMP procesando HSL respecto al programa secuencial.\textsuperscript{\ref{note:speedup}}}
\footnote{\label{note:speedup}La fórmula utilizada para medir el \textit{speed-up} experimental es 
$\text{Speed-up} = \frac{T_{s_n}}{T_{p_n}}$, donde $T_{s_n}$ es el tiempo secuencial medido con $n$ procesos y $T_{p_n}$ es el tiempo medido del programa paralelo con OpenMP utilizando $n$ hilos. Esto genera un margen de error asumible que podría ser solventado con la Ley de Amdahl.}

\rasterfigure[1]{yuvopenmp1}{Comparativa de tiempos de ejecución YUV.}
\rasterfigure[1]{yuvopenmp2}{Aceleración del programa OpenMP procesando YUV respecto al programa secuencial.}

\newpage
\rasterfigure[1]{grisesopenmp1}{Comparativa de tiempos de ejecución de la escala de grises.}
\rasterfigure[1]{grisesopenmp2}{Aceleración del programa OpenMP procesando la escala de grises respecto al programa secuencial.}

Como puede apreciarse, las métricas y visualizaciones anteriores muestran un patrón consistente para el procesamiento de color y escala de grises. La paralelización con OpenMP resulta en mejoras significativas en el rendimiento, especialmente en los primeros incrementos de hilos, pero el impacto disminuye gradualmente debido a factores inherentes al paralelismo como \textit{overheads}, sincronización y porciones no paralelizables del código. La aceleración o \textit{speed-up} conseguido demuestra un uso eficiente de recursos hasta límites prácticos impuestos por la arquitectura y la naturaleza del problema.